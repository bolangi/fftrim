#!/usr/bin/env perl
package fftrim;
use 5.006;
use strict;
use warnings;
use Path::Tiny;
use autodie ':all';
use feature 'say';
use Cwd;
use App::fftrim;
use Getopt::Long::Descriptive;

our ($opt, $usage,
	$current_dir,
	$control,
	$control_file,
	$dotdir ,
	$profile,
	$fh,
	$encoding_params,
	%length,
	$framerate,
	$finaldir,
	@lines,
	$is_error,
);

use Getopt::Long::Descriptive;
($opt, $usage) = describe_options(
   '%c %o',
   [ 'in=s',			"input file(s)"],
   [ 'out=s',			"output file"],
   [ 'start=s',			"start time"],
   [ 'end=s',			"end time"],
   [ 'profile=s',       'merge ffmpeg options from named file in $HOME/.fftrim'],
   [ 'source-dir=s',  	"source directory (batch mode)" ],
   [ 'target-dir=s',	"destination directory (batch mode)" ],
   [ 'c',      			"make output files conform to source file frame rate" ],
   [ 'n',      			"simulate: show output commands but do not run them" ],
   [ 'm',      			"simulate: show output commands omitting file checks" ],
   [ 'help',   			"print usage message and exit" ],
 );
print($usage->text, 
	"\nNote that options --in, --out, --start --end are not compatible with batch mode\n"),
	exit if $opt->{help} or ! keys %$opt;


$current_dir = getcwd;

# support old filename
($control_file) = grep{ -e } map{ join_path($opt->{source_dir},$_) }  qw(CONTROL CONTENTS);
-e $control_file or die "CONTROL file not found in $opt->{source_dir}";
$dotdir = join_path($ENV{HOME}, '.fftrim');
if ( ! -d $dotdir)
{	say qq(Directory "$dotdir" not found. Create it? y/n [Y]);
	my $answer = <STDIN>;
	mkdir $dotdir if $answer =~ /[yYjJ]/;
}
$profile = join_path($dotdir,  $opt->{profile} // 'default');
if ($profile =~ /\bdefault$/ and ! -e $profile )
{
	my $defaultfile = path($profile);
	say STDERR "creating default profile in $profile";
	$defaultfile->spew(<DATA>);
	say STDERR "edit the settings to suit your output targets or create additional profiles";
}
say STDERR "profile is $profile";
if ( -r $profile){ open $fh, '<', $profile }
else { $fh = *DATA }
$encoding_params = join '', grep {! /^#/} <$fh>;
$encoding_params =~ s/\n/ /g;

# handle command line mode 
if ($opt->{in} and $opt->{out} ){
	compress_and_trim_video($opt->{in}, $opt->{out}, $opt->{start} // 0, $opt->{end});
	exit
}


$finaldir = $opt->{target_dir};
mkdir $finaldir unless -e $finaldir;
-d $finaldir or die "$finaldir is not a directory!";

$control = path($control_file);
(@lines) = grep {! /^#/} map{ chomp; $_ } $control->lines;

process_lines(); # check for errors;
say(STDERR "Errors found. Fix $control_file and try again."), exit if $is_error;
process_lines("really do it! (but still may be a test)");



sub name_part  { my ($name) = /(.+?)(\.[a-zA-Z]{3})?$/ }
sub mp4 { $_[0] . '.mp4' }
sub to_mp4 { mp4(name_part($_[0])) }

sub trim_target { "$finaldir/$_[0]" }

sub concatenate_video {
	my ($target, @sources) = @_;
	$target .= ".mp4" unless $target =~ /mp4$/;
	say(STDERR "$target: file exists, skipping"), return if file_exists($target);
	my $parts = join '|', @sources;
	my $cmd = qq(ffmpeg -i concat:"$parts" -codec copy $target);
	say STDERR "concatenating: @sources -> $target";
	say $cmd;
	system $cmd unless simulate();
}
sub compress_and_trim_video {
	my ($input, $output, $start, $end) = @_;
	say(STDERR "$output: file exists, skipping"), return if file_exists( $output );
	$start //= 0;
	my @args = "ffmpeg";
	push @args, "-i $input";
	push @args, "-to $end" if $end;
	push @args, $encoding_params;
	push @args, "-ss $start" if $start;
	push @args, "-r $framerate" if $opt->{c};
	push @args, $output;
	my $cmd = join " ",@args;
	say $cmd;
	system $cmd unless simulate();
}
sub seconds {
	my $hms = shift;
	my $count = $hms =~ tr/:/:/;
	$count //= 0;
	# case 1, seconds only
	if (! $count)
	{
		return $hms
	}
	elsif($count == 1)
	{
		# m:s
	
		my ($m,$s) = split ':', $hms;
		return $m * 60 + $s
	}
	elsif($count == 2)
	{
		my ($h,$m,$s) = split ':', $hms;
		return $h * 3600 + $m * 60 + $s
	}
	else { die "$hms: something wrong, detected too many ':' characters" }
}
sub hms {
	my $seconds = shift;
	my $whole_hours = int( $seconds  / 3600 );
	$seconds -= $whole_hours * 3600;
	my $whole_minutes = int( $seconds / 60 );
	$seconds -= $whole_minutes * 60;
	$whole_minutes = "0$whole_minutes" if $whole_minutes < 10;
	$seconds = "0$seconds" if $seconds < 10;
	my $output;
	$output .=  "$whole_hours:" if $whole_hours;
	$output .=  "$whole_minutes:" if $whole_minutes > 0 or $whole_hours;
	$output .= $seconds;
	$output
}
sub decode_cutpoint {
	my ($pos, $sources) = @_;
	return unless $pos;
	# 1+2+24:15
	# 3-24:15 3rd file
	my ($nth, $time) = $pos =~ /(\d+)-([\d:]+)/;
	my $cutpoint; # this is a position in the final source file
	my $segments; # this is the count of the preceeding source files included at full length
	if ($nth){
		$cutpoint = $time;	
		$segments = $nth - 1;
	}
	else {
		my (@segments) = $pos =~ /(\d\+)?(\d\+)?(\d\+)?([^+]+)$/;
		@segments = grep{$_}map{ do { s/\+\s*//g; $_} if $_ } @segments;
		$cutpoint = (pop @segments) || 0;
		$segments = scalar @$sources - 1;  
	}
	my $total_length = seconds($cutpoint);
	for (0 .. $segments - 1){ $total_length += $length{$sources->[$_]} }
	#say "total length: $total_length";
	hms($total_length)
}
sub join_path { join '/',@_ }

sub simulate { $opt->{n} or $opt->{m} }
sub file_exists { $opt->{m} ? 0 : -e $_[0] }

sub video_length {
	my $videofile = shift;
	my $result = qx(ffmpeg -i "$videofile" 2>&1 | grep Duration | cut -d ' ' -f 4 | sed s/,//);
	chomp $result;
	$result
}
sub video_framerate {
	my $videofile = shift;
	my $result = qx(ffprobe "$videofile" 2>&1);
	my ($fps) = $result =~ /(\d+(.\d+)?) fps/;
}
__DATA__
# change the following ffmpeg arguments to suit
-c:v libx264
-preset:v medium
-profile:v main
-tune:v film
-s:v 640x360
-c:a aac
-b:a 80k
-ac 2
-ar 24000
-level 3

# don't change these arguments
-strict -2
# -copyts # causes problem rendering 20180923-2
