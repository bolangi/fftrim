#!/usr/bin/env perl
use strict;
use warnings;
use Path::Tiny;
use autodie ':all';
use feature 'say';
use Cwd;

use Getopt::Long::Descriptive;

my ($opt, $usage) = describe_options(
   '%c %o',
   [ 'source-dir=s',  	"source directory for video clips" ],
   [ 'target-dir=s',	"target directory for completed files" ],
   [ 'profile=s',       'use profile in $HOME/.fftrim, otherwise "default"'],
   [ 'in=s',			"input file  - single file mode"],
   [ 'out=s',			"output file - single file mode"],
   [ 'start=s',			"start time  - single file mode"],
   [ 'end=s',			"end time    - single file mode"],
   [ 'n',      			"simulate: show output commands but do not run them" ],
   [ 'm',      			"simulate: show output commands omitting file checks" ],
   [ 'help',   			"print usage message and exit" ],
 );
print($usage->text), exit if $opt->{help} or ! keys %$opt;

# 00000.MTS 00001.MTS 00002.MTS : 20170815-1 : 0:15 : # 1+2+11:41
# three .MTS files are to be concatentated into
# intermediate file 00000.mp4, then trimmed and 
# compressed into ../final/20170815-1.mp4

my $current_dir = getcwd;

# support old filename
my ($control_file) = grep{ -e } map{ join_path($opt->{source_dir},$_) }  qw(CONTROL CONTENTS);
-e $control_file or die "CONTROL file not found in $opt->{source_dir}";

my $profile = join_path($ENV{HOME}, '.fftrim',  $opt->{profile} // 'default');
say "profile is $profile";
my $fh;
if ( -r $profile){ open $fh, '<', $profile }
else { $fh = *DATA }
my $encoding_params = join '', grep {! /^#/} <$fh>;
$encoding_params =~ s/\n/ /g;
compress_and_trim_video($opt->{in}, $opt->{out}, $opt->{start} // 0, $opt->{end}), exit if $opt->{in} and $opt->{out};


my %length;
my $finaldir = $opt->{target_dir};
mkdir $finaldir unless -e $finaldir;
-d $finaldir or die "$finaldir is not a directory!";

my $control = path($control_file);
my (@lines) = grep {! /^#/} map{ chomp; $_ } $control->lines;
my $is_error;

process_lines(); # check for errors;
say(STDERR "Errors found. Fix $control_file and try again."), exit if $is_error;
process_lines("really do it! (but still may be a test)");

sub process_lines { 
	my $do = shift;
	foreach my $line (@lines){
		$line =~ s/\s+$//;
		say STDERR "line: $line";
		my ($source_files, $target, $start, $end) = split /\s+[:|]\s+/, $line;
		my @source_files = map{ join_path($opt->{source_dir}, $_)} split " ", $source_files;
		for (@source_files){
		if ( ! defined $length{$_} )
			{
				my $len = qx(video-length "$_");
				chomp $len;
				$length{$_} = seconds($len);
			}
		}
		say STDERR qq(no target for source files "$source_files". Using source name.) if not $target;
		$target //= $source_files[0];
		$target = mp4_target($target);
		my $ext = 'mp4';
		{
		no warnings 'uninitialized';
		say STDERR "source files: @source_files";
		say STDERR "target: $target";
		say STDERR "start time: $start";
		say STDERR "end time: $end";
		say(STDERR qq(no source files in line!! $line)), $is_error++, if not @source_files;
		my @missing = grep { ! -r } @source_files;
		say(STDERR qq(missing source files: @missing)), $is_error++, if @missing;
		}

		next unless $do;
		my $compression_source;
		if (@source_files > 1)
		{
			my $concat_target = mp4_target($source_files[0]);
			say STDERR "concat target: $concat_target";
			concatenate_video($concat_target, @source_files);
			$compression_source = $concat_target;
		} 
		else 
		{ 
			$compression_source = $source_files[0];
		}
			my $final = trim_target($target); 
			$start = decode_cutpoint($start, \@source_files);
			$end = decode_cutpoint($end, \@source_files);
			say STDERR "decoded start: $start, decoded end: $end";
			compress_and_trim_video(
				$compression_source,
				$final, 
				$start,
				$end
			);
	}
}

sub media_type {
	my ($in) = @{+shift};
	my ($ext) = lc( $in =~ /\.([a-z]{1,3})$/i );
	return "video" if $ext =~ /mpg|mov|m2v|mts|mp4|dvi/ ;
	return "audio" if $ext =~ /mp3|ogg|wav/ ;
}
sub is_video { media_type eq 'video' }
sub is_audio { media_type ne 'video' }

sub mp4_target { 
	my $file = shift;
	$file =~ s/\.(mov|m2v|mts)$//i;
	$file .= '.mp4' unless $file =~ /\.mp4$/;
	$file
}
sub trim_target { "$finaldir/$_[0]" }

sub concatenate_video {
	my ($target, @sources) = @_;
	$target .= ".mp4" unless $target =~ /mp4$/;
	say(STDERR "$target: file exists, skipping"), return if file_exists($target);
	my $parts = join '|', @sources;
	my $cmd = qq(ffmpeg -i concat:"$parts" -codec copy $target);
	say STDERR "concatenating: @sources -> $target";
	say $cmd;
	system $cmd unless simulate();
}
sub compress_and_trim_video {
	my ($input, $output, $start, $end) = @_;
	say(STDERR "$output: file exists, skipping"), return if file_exists( $output );
	# we don't need to transcode if no trimming and input is already mp4
	$start //= 0;
	my @args = "ffmpeg";
	push @args, "-i $input";
	push @args, "-to $end" if $end;
	push @args, $encoding_params;
	push @args, "-ss $start" if $start;
	push @args, $output;
	my $cmd = join " ",@args;
	say $cmd;
	system $cmd unless simulate();
}
sub seconds {
	my $hms = shift;
	my $count = $hms =~ tr/:/:/;
	$count //= 0;
	# case 1, seconds only
	if (! $count)
	{
		return $hms
	}
	elsif($count == 1)
	{
		# m:s
	
		my ($m,$s) = split ':', $hms;
		return $m * 60 + $s
	}
	elsif($count == 2)
	{
		my ($h,$m,$s) = split ':', $hms;
		return $h * 3600 + $m * 60 + $s
	}
	else { die "$hms: something wrong, detected too many ':' characters" }
}
sub hms {
	my $seconds = shift;
	my $whole_hours = int( $seconds  / 3600 );
	$seconds -= $whole_hours * 3600;
	my $whole_minutes = int( $seconds / 60 );
	$seconds -= $whole_minutes * 60;
	$seconds = "0$seconds" if $seconds < 10;
	my $output;
	$output .=  "$whole_hours:" if $whole_hours;
	$output .=  "$whole_minutes:" if $whole_minutes;
	$output .= $seconds;
	$output
}
sub decode_cutpoint {
	my ($pos, $sources) = @_;
	# 1+2+24:15
	return unless $pos;
	my (@segments) = $pos =~ /(\d\+)?(\d\+)?(\d\+)?([^+]+)$/;
	@segments = grep{$_}map{ do { s/\+\s*//g; $_} if $_ } @segments;
	my $cutpoint = (pop @segments) || 0;
	my $total_length = 0;
	$total_length += seconds($cutpoint);
	for (0 .. scalar @$sources-1){
		$total_length += $length{$sources->[$_]} if $_ < @segments;
	}
	#say "total length: $total_length";
	hms($total_length)
}
sub join_path { join '/',@_ }

sub simulate { $opt->{n} or $opt->{m} }
sub file_exists { $opt->{m} ? 0 : -e $_[0] }

__DATA__
-c:v libx264
-preset:v medium
-profile:v main
-tune:v film
# -r 25 # in future this could come from ffprobe, so we always use the same framerate as source files
-s:v 640x360
-c:a aac
-b:a 80k
-ac 2
-ar 24000
# raise the volume with a limiter to minimize clipping effects
#-filter_complex aresample=96000,alimiter=level_in=1:level_out=5:limit=0.18:attack=3:release=50:level=disabled,lowpass=f=12000,highpass=f=200
-level 3
-strict -2
-copyts
